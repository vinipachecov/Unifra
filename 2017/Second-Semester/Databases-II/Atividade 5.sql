--1 - Criar um trigger que antes de inserir um ITENsVENDA, busque o valor do produto (tabela PRODUTOS) e atribua ao valor unitário de ITENSVENDA.

CREATE OR ALTER TRIGGER T_VALORUNITARIO_ITEMVENDA FOR ITEMVENDA
ACTIVE BEFORE INSERT OR UPDATE POSITION 6
AS
	DECLARE VARIABLE VALUNIT D_DECIMAL;		
BEGIN 
	SELECT FIRST 1 P.VALORUNITARIO
	FROM PRODUTO P
	WHERE P.CODIGO = NEW.CODPRODUTO
	INTO :VALUNIT;
	
	NEW.VALORUNITARIO =:VALUNIT;
END

SELECT * FROM ITEMVENDA;

SELECT * FROM PRODUTO;

INSERT INTO ITEMVENDA(CODPRODUTO,CODVENDA,TOTAL,QUANTIDADE)
VALUES
(14,7,30000,100);


--2 - Criar triggers para calcular o valor total do produto após inserir/atualizar um item da compra 
''--(caso a compra não tenha sido finalizada). Calcular o subtotal e total da compra.
CREATE EXCEPTION E_COMPRA_FINALIZADA 'Compra já finalizada.'

SELECT * FROM PRODUTO;

-- Pega valor unitario do produto correspondente ao itemcompra
CREATE OR ALTER TRIGGER T_ITEMCOMPRAVALU_2 FOR ITEMCOMPRA
ACTIVE AFTER INSERT OR UPDATE POSITION 1
AS
	DECLARE VARIABLE subt D_DECIMAL;
	DECLARE VARIABLE FINALIZADA D_FINALIZADA;
BEGIN
	SELECT FIRST 1 C.FINALIZADA  
	FROM COMPRA C 
	WHERE C.CODIGO = NEW.CODCOMPRA
	INTO :FINALIZADA;	

	IF(( :FINALIZADA = 'N'))THEN	
	begin
	SELECT sum(ic.VALORUNITARIO*ic.QUANTIDADE)
	FROM ITEMCOMPRA ic
	WHERE ic.CODCOMPRA = NEW.codcompra
	INTO :subt;
	
	UPDATE COMPRA C
	SET c.SUBTOTAL=:subt,
	    c.TOTAL=:subt-c.DESCONTO
	WHERE c.CODIGO=NEW.codcompra;
	
	UPDATE produto p
	SET p.VALORUNITARIO=NEW.valorunitario,
	    p.QUANTIDADEATUAL=p.QUANTIDADEATUAL+NEW.quantidade
	WHERE p.CODIGO=NEW.codproduto;
	END
	ELSE
		EXCEPTION E_COMPRA_FINALIZADA;
END

-- CÓDIGOS AUXILIARES 

	SELECT SUM(IT.TOTAL)
	FROM ITEMCOMPRA IT
	INNER JOIN COMPRA C ON IT.CODCOMPRA = C.CODIGO
	
	
SELECT * FROM PRODUTO;

SELECT * FROM ITEMCOMPRA;

SELECT * FROM COMPRA;

--3 - Criar triggers para calcular o valor total do produto antes de inserir/atualizar um item da venda (caso a venda 
--não tenha sido finalizada). Calcular o subtotal e total da venda.
--Que impeça a inclusão, alteração ou exclusão de um item da venda caso a compra tenha sido finalizada.

CREATE EXCEPTION E_COMPRA_FINALIZADA 'Compra finalizada, não é possível alterar.';
CREATE EXCEPTION E_VENDA_FINALIZADA 'Venda finalizada, não é possível alterar.';

SELECT * FROM ITEMVENDA;

DROP TRIGGER T_TOTALVENDA;

SELECT * FROM VENDA

CREATE OR ALTER TRIGGER T_TOTALITEMVENDA FOR ITEMVENDA
ACTIVE BEFORE INSERT OR UPDATE POSITION 3
AS
	DECLARE VARIABLE FINALIZADA D_FINALIZADA;
BEGIN
	SELECT FIRST 1 V.FINALIZADA  
	FROM VENDA V 
	WHERE V.CODIGO = NEW.CODVENDA
	INTO :FINALIZADA;	
	IF(( :FINALIZADA = 'N'))THEN
	BEGIN
		NEW.TOTAL = NEW.QUANTIDADE * NEW.VALORUNITARIO;
	END
END


--SUBTOTAL E TOTAL DA VENDA
CREATE OR ALTER TRIGGER T_TOTALVENDA FOR ITEMVENDA
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
	DECLARE VARIABLE TOTALVENDA D_DECIMAL;
	DECLARE VARIABLE FINALIZADA D_FINALIZADA;
BEGIN 
	SELECT FIRST 1 V.FINALIZADA  
	FROM VENDA V 
	WHERE V.CODIGO = NEW.CODVENDA
	INTO :FINALIZADA;
	
	IF(( :FINALIZADA = 'N'))THEN
	BEGIN		
		SELECT SUM(IT.TOTAL)
		FROM ITEMVENDA IT		 
		WHERE IT.CODVENDA = NEW.CODVENDA
		INTO :TOTALVENDA;	
	
		UPDATE VENDA V
		SET V.TOTAL = :TOTALVENDA,
		V.SUBTOTAL = :TOTALVENDA - ( :TOTALVENDA * V.DESCONTO)
		WHERE V.CODIGO = NEW.CODVENDA;		
	END	
	ELSE 
		EXCEPTION E_VENDA_FINALIZADA;
END


SELECT * FROM ITEMVENDA;

SELECT* FROM VENDA;


--4 - Criar uma Visão que mostre a data da venda, numero da NF, subtotal, desconto, total e o nome do cliente 
--para as vendas do ano de 2017

CREATE VIEW COMPRACLIENTE(
      DATAVENDA,
      NUMERONF,
    SUBTOTAL,
    DESCONTO,
    TOTAL,
    NOMECLIENTE)
  AS
  SELECT V.DATAVENDA, V.NUMERONF, V.SUBTOTAL, V.DESCONTO, V.TOTAL, C.NOME
  FROM VENDA V
  INNER JOIN CLIENTE C ON V.CODCLIENTE = C.CODIGO
  WHERE EXTRACT(YEAR FROM V.DATAVENDA) = '2017';
  
  SELECT * FROM COMPRACLIENTE;
  
  
-- CODIGO AUXILIAR  
  SELECT V.DATAVENDA, C.NOME, V.TOTAL 
  FROM VENDA V
  INNER JOIN CLIENTE C ON V.CODCLIENTE = C.CODIGO
  WHERE EXTRACT(YEAR FROM V.DATAVENDA) = '2017'

--5 - Fazer uma stored procedure que receba como parâmetro de entrada o código do cliente e calcule o número de vendas que o mesmo realizou, efetuando a atualização do número de vendas (tabela CLIENTE). 

  CREATE OR ALTER PROCEDURE SP_NUMVENDA_CLIENTE(IDCLIENTE D_INTEIRO)
  AS
  	DECLARE VARIABLE NUMVENDAS D_INTEIRO;
  	BEGIN	  	
  		SELECT COUNT(V.CODCLIENTE)
  		FROM VENDA V
  		WHERE V.CODCLIENTE = :IDCLIENTE
  		INTO :NUMVENDAS;
  		
  		UPDATE CLIENTE C
  		SET C.NUMEROVENDAS = :NUMVENDAS
  		WHERE C.CODIGO = :IDCLIENTE;  		
  		SUSPEND;	  	
  	END 

  	EXECUTE PROCEDURE SP_NUMVENDA_CLIENTE(6);  	
  	
  	SELECT * FROM CLIENTE;
  	
  	SELECT * FROM VENDA;
  
--6 - Criar uma visão que mostre todos os produtos vendidos de uma marca específica nos 2 primeiros meses do 2º semestre do ano de 2017.

  SELECT * FROM MARCA;
  
  CREATE VIEW TOTAL_VENDIDOS_MARCA(
      NOMEPRODUTO,
      DATAVENDA,
      QUANTIDADE,
    TOTAL,
    CODVENDA)
  AS
	  SELECT P.NOME, V.DATAVENDA, IV.QUANTIDADE, IV.TOTAL, IV.CODVENDA  
	  FROM VENDA V
	  INNER JOIN ITEMVENDA IV ON V.CODIGO = IV.CODVENDA
	  INNER JOIN PRODUTO P ON IV.CODPRODUTO = P.CODIGO
	  WHERE EXTRACT(YEAR FROM V.DATAVENDA) = '2017' AND (EXTRACT(MONTH FROM V.DATAVENDA) >= 6 AND EXTRACT(MONTH FROM V.DATAVENDA) < 8)
  
  
	  --TESTE
  SELECT * FROM TOTAL_VENDIDOS_MARCA;
  
   
  
  

--7 - Elaborar uma Stored Procedure que receba como parâmetro TODOS os dados de um PRODUTO (exceto as IDs), juntamente com o nome da marca e o nome do tipo.
--Verificar se a MARCA e TIPO existem em suas respectivas tabelas e retornar suas IDs.
--Caso não existam, inserir na respectiva tabela e recuperar a ID.
--Inserir os dados completos do PRODUTO.
  
  SELECT * FROM PRODUTO;
  
  CREATE EXCEPTION E_MARCA_JA_EXISTE 'Marca ja existente!';
  
  CREATE OR ALTER PROCEDURE SP_EXISTE_PRODUTO_INSERE (NOMEPRODUTO D_NOME , QUANTIDADEMINIMA D_INTEIRO, QUANTIDADEATUAL D_INTEIRO, VALORUNITARIO D_DECIMAL, UNIDADE D_STR020,
  NOMETIPO D_NOME , NOMEMARCA D_NOME)
  AS
  		DECLARE VARIABLE IDM D_INTEIRO;
    	DECLARE VARIABLE IDTIPO D_INTEIRO;
  	BEGIN
	  	EXECUTE PROCEDURE SP_EXISTE_MARCA_INSERE(:NOMEMARCA)
	  	RETURNING_VALUES :IDM;
	  	EXECUTE PROCEDURE SP_EXISTE_TIPO_INSERE(:NOMETIPO)
	  	RETURNING_VALUES :IDTIPO;
	  	INSERT INTO PRODUTO(CODTIPO, CODMARCA, NOME, QUANTIDADEMINIMA, QUANTIDADEATUAL, VALORUNITARIO, UNIDADE)
	  	VALUES(:IDTIPO, :IDM, :NOMEPRODUTO, :QUANTIDADEMINIMA, :QUANTIDADEATUAL, :VALORUNITARIO, :UNIDADE);
	  	SUSPEND;
  	END 
  
  	
  	
  	
  	EXECUTE PROCEDURE SP_EXISTE_PRODUTO_INSERE('Pasta de Amendoim Power One',50,100,20,'Kg','Pasta de Amendoim','Power One');
  	
  	SELECT * FROM  TIPO;
  	
  	SELECT * FROM MARCA;
  	
  	SELECT * FROM PRODUTO;  	
  	
  	-- Insere marca
 

  
  --Insere tipo
  CREATE OR ALTER PROCEDURE SP_EXISTE_TIPO_INSERE (NOMETIPO D_NOME)  
  RETURNS( 
  	IDTIPO D_INTEIRO                                               
  	)
  AS  	
  BEGIN
	  IF (NOT EXISTS (SELECT FIRST 1 T.NOME
	  			   FROM TIPO T
	  			   WHERE T.NOME = :NOMETIPO))	  			   
	  			   THEN
		  			   BEGIN
			  			   INSERT INTO TIPO(NOME)
			  			   VALUES(:NOMETIPO);			  			  		  			   
		  			   END 		  			   
		     SELECT FIRST 1 T.CODIGO
  			   FROM TIPO T 
			   WHERE T.NOME = :NOMETIPO
			   INTO :IDTIPO; 
			   SUSPEND;	
  END 
  
    
    
  
CREATE PROCEDURE SPI (IDVENDA WT, IDCOMPRA INT)
AS
BEGIN
	IF(:IDVENDA IS NOT NULL) THEN
	INSERT INTO HISTORICOESTOQUE(IDVENDA,IDPROD,QUANT,VLRUNIT)
	VALUES(:IDVENDA,:IDPROD,:QIT,:VLR);
	ELSE
	IF(:IDCOMPRA IS NOT NULL) THEN
	INSERT INTO HITORICOESTOQUE(IDCOMPRA, IDPROD, QUANT, VLRUNIT)
	VALUES(:IDCOMPRA, :IDPROD, :QT, :VLR)
END;

CREATE TRIGGER SP+** FOR INTEMVENDA
ACTIVE AFTER INSERT OR UPDATE POSITION 5
BEGIN 
	EXECUTE PROCEDURE SPINHIST
	(NEW.IDVENDA, NULL, NEW.QUANT, NEW.VLRUNIT,NEW.IDPROD);
END